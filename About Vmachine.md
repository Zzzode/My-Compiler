# 1 寄存器和内存

1. 寄存器:
   - `PC`: 程序计数器，存放的是一个内存地址，地址指向的是下一条需要执行的计算机指令。
   - `SP`: 指针寄存器，指向当前栈顶。入栈时sp--，栈是高地址向低地址增长。
   - `BP`: 基地址指针，也指向栈的其他位置，函数调用时会使用。
   - `AX`: 通用寄存器，用于存放一条指令执行后的结果。

2. 内存:
   - `text segment`: 用于存放指令。
   - `data segment`: 用于存放初始化后的数据，以字符串存储。
   - `stack segment`: 用于处理函数调用等数据，如calling frame或是函数的局部变量。
   - `heap segment`: 从栈底开始增长，用于为程序动态分配内存。程序没有实现。

# 2 指令

1. `MOV`指令做了拆分，分为`IMM, LC, LI, SC, SI`

   - `IMM <num>` 将 `<num>` 放入寄存器 ax 中。
   - `LC` 将对应地址中的字符载入 AX 中，要求 AX 中存放地址。
   - `LI` 将对应地址中的整数载入 AX 中，要求 AX 中存放地址。
   - `SC` 将 AX 中的数据作为字符存放入地址中，要求栈顶存放地址。
   - `SI` 将 AX 中的数据作为整数存放入地址中，要求栈顶存放地址。

2. `PUSH`
3. `JMP`
4. `JZ, JNZ`
5. **子函数调用**，包括了五个指令`CALL, RET, ENT, ADJ, LEV`和一个`LEA`

    - 由于子函数调用结束之后会回到原函数继续运行，因而需要保存原函数状态

    - 如果子函数由返回，则保存在`AX`寄存器中

    - C-语言子函数调用规则：
      1. 调用者将参数入栈
      2. 调用结束之后，参数出栈
      3. 参数顺序入栈（C语言为逆序）

    - `ENT`指令用于实现子函数调用框架：
      - 保存栈指针
      - 栈上保留一定空间用以存放局部变量

    - `ADJ`用于将子函数压栈数据清除。
    - `LEV`指令合并了返回原函数的`MOV, POP, RET`这三个指令，所以`RET`指令被注释了。

    - `LEA`指令用于取栈中的内容，后面跟的参数为偏移量，即为`LEA <offset>`

6. 运算符指令包括`OR, XOR, AND, EQ, NE, LT, GT, LE, GE, SHL, SHR, ADD, SUB, MUL, DIV, MOD`
7. 内置函数包括`OPEN, READ, CLOS, PRTF, MALC, MSET, MCMP, EXIT`
